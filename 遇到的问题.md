# 1.单例模式启动日志线程的死锁问题
问题:若在线程Thread类的启动过程中的某处进行log的话会导致死锁，原因如下:第一次log时最后会通过getInstance来获取实例，故pthread_once中的init函数会被调用，此函数内部先创建一个AsyncLog对象，再启动之,此时会进入到Thread启动的内部，若在启动过程中进行了log操作，那么又会进入一次getInstance来获取实例，然而此时pthread_once还未退出，那么第二次的log就会等待，结果就是造成了典型的单线程死锁:第一次log在等待第二次log的结束以便退出pthread_once然后返回实例，而第二次log又在等待第一次log结束以便获取实例，前后死锁。  
解决方案:不在Thread的启动过程中进行log操作即可。  
# 2.epoll采用et模式时accept只接收有限的连接 
问题:本项目的epoll默认采取了et模式，而最初在accept时并未采取一直accept直至暂时无新连接的方式，而是一次一个，这样的结果就是压测时并发连接一上来(同时抵达触发事件就绪)只能有少量的连接被建立。  
解决方案:accept也放到while循环中直至当前暂时无新连接,原因在于同时有多个并发连接到来时，如果只accept一次，那么后续的连接就会继续等待就绪队列中，直至下一次新的连接到来，而accept默认是取就绪队列的第一个连接的，那么后续的处理就会出错。   
解决方案:使用while包住accept直至accept返回-1并且errno为EAGAIN才退出,
# 3.webbench压测时结果全部为0
问题:webbench压测成功、失败的结果都是0，原因是压测需要服务端主动关闭连接(短连接情况下)。  
解决方案:通过在发送完响应后就将当前连接状态置为正在断开连接状态以便后续在往内核缓冲区写完数据后可以及时关闭连接，改完后压测正常了；  
# 4.SIGPIPE信号的处理
问题:经常会收到SIGPIPE信号。  
解决方案:对于对端主动关闭连接的处理方式(不管是全关闭或是只关闭写端)是这样的:对端关闭连接后本端读事件会就绪一次(因为发送了FIN分节),那么read会返回0，这时候会将连接状态置为正在关闭，后续write时若为半关闭则继续写即可，若为全关闭会在第二次write时报错SIGPIPE(第一次对应的套接字上会收到RST响应),该信号的默认行为是终止进程，那么解决起来也很简单，忽略这个信号就行。   
# 5.偶尔的段错误问题 
问题:偶尔会遇到段错误。  
解决方案:后续检查之后发现应该是Connection对象的生命周期管理问题，在readCallback_的一系列回调最终有可能关闭连接，但此时不应该销毁Connection,即需要延长一下生命期，因为Event::handleEvent在处理完读事件后还可能需要处理写事件，而写事件是需要访问Connection的用户态缓冲区的，那么如果Connection被销毁的话，就会造成非法访问，结果是Undefined Behaviour，即可能出错，也可能不出错，取决于这块内存是否被系统分配作他用了。解决办法就是在Event中增加一个tie函数即一个weak_ptr对象用于指向其owner对象，这里就是Connection,如果一个Event对象调用过tie的话,每次handleEvent时需要先进行weak_ptr的类型提升以延长Connection的生命期。   

            
