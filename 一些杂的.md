# 对象生命周期的管理    
## 线程的析构  
Thread对象析构时会调用pthread_join等待线程退出,这个一般由上层对象调用，其会先将循环的条件改为false以便线程的正常退出；  
# 用到RAII模式的地方  
1)、Mutex、MutexGuard、Condition;  
2)、Logger;  
3)、Connection是以std::shared_ptr包裹的；  
# 交换指针以减小临界区(Copy On Write)
1)、AsyncLog::writeToFile;  
2)、EventLoop::executeCallbacks;  
# 关于内存泄漏的检测 
由于正常情况下服务端一直在一个循环中等待事件驱动，故用valgrind直接进行检测的话肯定不行，这里通过在main reactor中注册一个定时器事件(5s)，超时关闭服务端，然后再查看服务端完全结束后的内存泄漏情况，结果是没有内存泄漏的:  
![memory_leak](./results/实验室电脑虚拟机环境下测试结果/内存泄漏.png)  
然后测试下有并发连接情况下的内存泄漏，测试如下:通过webbench压测30s(短连接),而定时器事件35s后关闭服务端,结果如下:  
![memory_leak2](./results/实验室电脑虚拟机环境下测试结果/内存泄漏2.png)  
# 关于任务队列的改进
线程池的任务队列使用了加锁的方式来保证数据的一致性，另一种方法可以通过无锁队列来实现，而其基础即为所谓的CAS(compare and swap)。它是CPU的一个指令，可以保证原子性地比较+交换值(成功的话，失败直接返回);C++11的std::atomic也可以实现原则操作;  
